#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

#pragma kernel T main=T
#pragma kernel LP main=LP
#pragma kernel SS main=SS
#pragma kernel AP main=AP
#pragma kernel GI main=GI
#pragma kernel MS main=MS
#pragma kernel MSAcc main=MSAcc

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "../../common/shaders/ExpanseSkyCommon.hlsl"
#include "../../sky/ExpanseSkyMapping.hlsl"
#include "../../sky/ExpanseSky.hlsl"

/* RW Textures. */
/* Transmittance. */
RW_TEXTURE2D(float3, _T_RW);

/* Light Pollution. */
RW_TEXTURE2D(float3, _LP_RW);

/* Single scattering. */
RW_TEXTURE2D(float3, _SS_RW);

/* Aerial perspective. */
RW_TEXTURE3D(float3, _AP_RW);

/* Multiple scattering. */
RW_TEXTURE2D(float3, _MS_RW);

/* Multiple scattering accumulation. */
RW_TEXTURE2D(float3, _MSAcc_RW);

/* Ground Irradiance. */
RW_TEXTURE2D(float3, _GI_RW);

[numthreads(8,8,1)]
void T(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle and a
   * height. */
  float u_r = (id.x + 0.5f) / float(_resT.x);
  float u_mu = (id.y + 0.5f) / float(_resT.y);

  float2 r_mu = unmapSky2DCoord(u_r, u_mu, _atmosphereRadius, _planetRadius, _resT.y);

  float r = r_mu.x;
  float mu = r_mu.y;

  float3 O = float3(0, r, 0);
  float3 d = normalize(float3(safeSqrt(1 - mu * mu), mu, 0));

  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);

  // /* Compute optical depth for all enabled atmosphere layers. */
  //
  // float3 power = float3(0, 0, 0);
  // for (int i = 0; i < _numActiveLayers; i++) {
  //   float opticalDepth = computeOpticalDepth(_layerDensityDistribution[i],
  //     O, endPoint, _layerHeight[i], _layerThickness[i], _layerDensity[i],
  //     _layerAttenuationBias[i], _layerAttenuationDistance[i],
  //     _layerUseDensityAttenuation[i], _numTSamples);
  //   power += opticalDepth * _layerCoefficientsA[i].xyz;
  // }

  /* Compute transmittance from optical depth. */
  _T_RW[id.xy] = computeTransmittance(O, d, intersection.endT);
}

[numthreads(8,8,1)]
void LP(uint3 id : SV_DispatchThreadID) {
  // /* Get the uv for this id and unwrap it to a viewing angle and a
  //  * height. */
  // float u_r = (id.x + 0.5f) / float(_resLP.x);
  // float u_mu = (id.y + 0.5f) / float(_resLP.y);
  //
  // float2 r_mu = unmapSky2DCoord(u_r, u_mu, _atmosphereRadius, _planetRadius);
  //
  // float r = r_mu.x;
  // float mu = r_mu.y;
  //
  // float3 O = float3(0, r, 0);
  // float3 d = float3(safeSqrt(1 - mu * mu), mu, 0);
  //
  // /* Trace a ray to see what we hit. */
  // SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
  //   _atmosphereRadius);
  // float3 endPoint = O + d * intersection.endT;
  // float t_hit = intersection.endT;
  //
  // float2 oToSample = mapSky2DCoord(length(O), mu, _atmosphereRadius,
  //   _planetRadius, t_hit, intersection.groundHit, _resT.y);
  //
  // float3 lightPollution[MAX_LAYERS];
  // float scaledDensity[MAX_LAYERS];
  // for (int i = 0; i < MAX_LAYERS; i++) {
  //   lightPollution[i] = float3(0, 0, 0);
  //   scaledDensity[i] = 0;
  // }
  //
  // for (int i = 0; i < _numLPSamples; i++) {
  //   float sampleT = 0.0;
  //   float ds = 0.0;
  //   if (_useImportanceSampling) {
  //     float2 t_ds = generateCubicSampleFromIndex(i, _numLPSamples);
  //     sampleT = t_hit * t_ds.x;
  //     ds = t_ds.y;
  //   } else {
  //     /* Distribute linearly. */
  //     float2 t_ds = generateLinearSampleFromIndex(i, _numLPSamples);
  //     sampleT = t_hit * t_ds.x;
  //     ds = t_ds.y;
  //   }
  //
  //   float3 samplePoint = O + d * sampleT;
  //   float3 normalizedSamplePoint = normalize(samplePoint);
  //
  //   /* Compute the scaled density for each layer.  */
  //   for (int j = 0; j < _numActiveLayers; j++) {
  //     scaledDensity[j] = ds * computeDensity(_layerDensityDistribution[j],
  //       samplePoint, _layerHeight[j], _layerThickness[j], _layerDensity[j],
  //       _layerUseDensityAttenuation[j], sampleT, _layerAttenuationBias[j],
  //       _layerAttenuationDistance[j]);
  //   }
  //
  //   /* Compute transmittance from O to sample point. */
  //   float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_T, s_linear_clamp_sampler,
  //     oToSample, 0);
  //
  //   /* Our transmittance value for O to the sample point is too large---we
  //    * need to divide out the transmittance from the sample point to the
  //    * atmosphere, or ground, depending on what we hit. */
  //   float2 sampleOut = mapSky2DCoord(length(samplePoint),
  //     clampCosine(dot(normalizedSamplePoint, d)), _atmosphereRadius,
  //     _planetRadius, t_hit - sampleT, intersection.groundHit, _resT.y);
  //   float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_T, s_linear_clamp_sampler,
  //     sampleOut, 0).xyz;
  //   T_oToSample -= T_sampleOut;
  //
  //   /* Compute the light transmittance to the ground. */
  //   float2 sampleToGround = mapSky2DCoord(length(samplePoint), -1.0,
  //     _atmosphereRadius, _planetRadius, length(samplePoint) - _planetRadius,
  //     true, _resT.y);
  //   float3 T_sampleToGround = SAMPLE_TEXTURE2D_LOD(_T, s_linear_clamp_sampler,
  //     sampleToGround, 0).xyz;
  //
  //   float3 T = exp(T_oToSample + T_sampleToGround);
  //
  //   for (int j = 0; j < _numActiveLayers; j++) {
  //     lightPollution[j] += scaledDensity[j] * T;
  //   }
  // }
  //
  // for (int i = 0; i < _numActiveLayers; i++) {
  //   _LP_RW[uint3(id.xy, (uint) i)] = lightPollution[i];
  // }
}

[numthreads(8,8,1)]
void SS(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle and a
   * radial angle. */
  float u_mu = (id.x + 0.5) / float(_resSS.x);
  float u_theta = (id.y + 0.5) / float(_resSS.y);

  float3 O = GetCameraPositionPlanetSpace();
  float r = length(O);

  float2 mu_theta = unmapSkyRenderCoordinate(r, u_mu, u_theta,
    _atmosphereRadius, _planetRadius, _resSS.x, _resSS.y);

  float3 d = mu_theta_to_d(mu_theta.x, mu_theta.y, O);

  /* Check if we hit the ground. TODO: maybe just check against horizon
   * angle? Hm. TODO: need to case out above atmo. */
  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);

  SSResult ss = computeSS(O, d, intersection.endT, intersection.endT, intersection.groundHit);

  // _SS_RW[id.xy] = 0.99 * _SS_RW[id.xy] + 0.01 * ss.shadows;
  _SS_RW[id.xy] = ss.shadows;
}

[numthreads(4,4,4)]
void AP(uint3 id : SV_DispatchThreadID) {
  // TODO: diff between ground and sky is causing artifacts I think.
  // need to clamp, or do some kind of thing like that? not sure.
  // other thing though is that they follow the texture. when you look
  // right at the horizon, there's a vertical line that sweep across
  // with the vertical coordinate. and then there's the horizon coordinates.
  // It's definitely some kind of mini-aliasing issue.
  // The reason it's so big is because the AP texture is so low res. If I
  // up the AP texture res, it gets thinner and thinner. It's probably only
  // a pixel wide, again suggesting the aliasing issue.
  // The other weird thing is that it seems to deal with thin atmo layers
  // weirdly. I create a really thin layer, and then I point the camera at
  // the ground, and somehow it creates fog at the top of the camera but
  // not at the bottom? It creates fog on the mountain, where it shouldn't
  // be. interesting. This suggests something with the frustum mapping
  // for sure. Plus the resolution issue with the AP texture points to the
  // fact that it's an issue there, not with the sky mapping.

  // It's like, when I'm pointed up, it looks right, but it has the artifacts.
  // And when I'm pointed down, it looks clearly wrong.

  // Adjusting to a high FOV makes it easier to observe.

  // A thin, dense, tent layer makes it extremely obvious that the frustum
  // map is f-ed in some way as well.

  // As a final note for tonight, changing the screen resolution just by
  // dragging it changes how it fucks up. So there's 100% something fishy
  // going on.

  // A possible good place to start tomorrow would be manually displaying
  // the frustum uv's at a fixed depth.

  /* Get the uv for this id and unwrap it to frustum coordinates. */
  float3 uvw = (id + 0.5) / _resAP.xyz;
  float4 xyz = unmapFrustumCoordinate(uvw);
  float3 d = normalize(xyz.xyz); // TODO: normalize not necessary
  // HACK
  // if (d.y > 0.0 && d.y < 0.05) {
  //   d.y = 0.05;
  // }
  // if (d.y < 0.0 && d.y > -0.05) {
  //   d.y = -0.05;
  // }
  float depth = xyz.w;

  /* Compute SS between origin and depth in direction d. */
  float3 O = GetCameraPositionPlanetSpace();
  /* Check if we hit the ground. TODO: maybe just check against horizon
   * angle? Hm. TODO: need to case out above atmo. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);
  depth = min(depth, intersection.endT);

  /* TODO: make samples tweakable? */
  // SSResult ss = computeSS(O, d, min(depth, intersection.endT), intersection.endT, intersection.groundHit);
  // float3 ms = computeMS(O, d, min(depth, intersection.endT), intersection.endT, intersection.groundHit);

  SSResult ss = computeSS(O, d, depth, intersection.endT, intersection.groundHit);
  float3 ms = computeMS(O, d, depth, intersection.endT, intersection.groundHit);
  //
  // SSResult ss = computeSS(O, d, depth, intersection.groundHit);
  // float3 ms = computeMS(O, d, depth, intersection.groundHit);

  /* Compute the transmittance between the 2 points. */
  float muO = dot(normalize(O), d);
  float2 oToSample = mapSky2DCoord(length(O), muO, _atmosphereRadius,
    _planetRadius, intersection.endT, intersection.groundHit, _resT.y);
  float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_T,
    s_linear_clamp_sampler, oToSample, 0).xyz;

  float depthSample = O + d * depth;
  float muSample = dot(normalize(depthSample), d);
  float2 sampleOut = mapSky2DCoord(length(depthSample), muSample, _atmosphereRadius,
    _planetRadius, intersection.endT - depth, intersection.groundHit, _resT.y);
  float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_T,
    s_linear_clamp_sampler, sampleOut, 0).xyz;
  T_oToSample -= T_sampleOut;

  _AP_RW[id] = float4(ss.shadows + ms, dot(float3(1, 1, 1)/3, T_oToSample));
  // TODO: FRUSTUM DEBUG
  // _AP_RW[id] = float4(depth, depth, depth, 1);
}

[numthreads(8,1,1)]
void GI(uint3 id : SV_DispatchThreadID) {
  // float u_mu_l = (id.x + 0.5f) / float(_resGI);
  //
  // float2 r_mu_l = unmapSky1DCoord(u_mu_l, _planetRadius);
  // float r = r_mu_l.x;
  // float mu_l = r_mu_l.y;
  //
  // float3 O = float3(0, r, 0);
  // float3 O_normalized = float3(0, 1, 0);
  // float3 L = float3(safeSqrt(1 - mu_l * mu_l), mu_l, 0);
  //
  // /* Precompute outside of loop. */
  // float3 proj_L = normalize(L - O_normalized * mu_l);
  //
  // float3 gi[MAX_LAYERS];
  // for (int j = 0; j < _numActiveLayers; j++) {
  //   gi[j] = float3(0, 0, 0);
  // }
  //
  // for (int i = 0; i < _numGISamples; i++) {
  //   /* Generate fibonacci hemisphere dir based on i. */
  //   float3 d = fibonacciHemisphere(i, _numGISamples);
  //
  //   float mu = dot(d, O_normalized);
  //   float3 proj_d = normalize(d - O_normalized * dot(O_normalized, d));
  //   float nu = clampCosine(dot(proj_L, proj_d));
  //
  //   /* Check to see if we hit the sky. */
  //   SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
  //     _atmosphereRadius);
  //   if (!intersection.groundHit) {
  //     float t_hit = intersection.endT;
  //     TexCoord4D ssCoord = mapSky4DCoord(r, mu, mu_l, nu,
  //       _atmosphereRadius, _planetRadius, t_hit, false, _resSS.x, _resSS.y,
  //       _resSS.z, _resSS.w);
  //     float dot_L_d = dot(L, d);
  //     for (int j = 0; j < _numActiveLayers; j++) {
  //       /* Compute single scattering contribution using phase function. */
  //       float3 ss = t_hit * sampleSSTexture(ssCoord, j);
  //       float phase = computePhase(dot_L_d, _layerAnisotropy[j], _layerPhaseFunction[j]);
  //       gi[j] += ss * phase;
  //     }
  //   }
  // }
  //
  // for (int i = 0; i < _numActiveLayers; i++) {
  //   _GI_RW[float3(id.xy, i)] = gi[i] * 2 * PI / float(_numGISamples);
  // }
}

[numthreads(8,8,1)]
void MS(uint3 id : SV_DispatchThreadID) {
  /* Unmap the uv coordinates to get the light direction and sample point. */
  float u_r = (id.x + 0.5f) / float(_resMS.x);
  float u_mu_l = (id.y + 0.5f) / float(_resMS.y);

  float2 r_mu_l = unmapMSCoordinate(u_r, u_mu_l, _atmosphereRadius, _planetRadius);

  float r = r_mu_l.x;
  float mu_l = r_mu_l.y;

  float3 O = float3(0, r, 0);
  float3 O_normalized = float3(0, 1, 0);
  float3 L = float3(safeSqrt(1 - mu_l * mu_l), mu_l, 0);

  /* Sample a bunch of directions, uniformly distributed on a sphere. */
  float3 secondOrder = float3(0, 0, 0);
  float3 transferFunction = float3(0, 0, 0);
  for (int i = 0; i < _numMSSamples; i++) {
    /* Get the sample direction. */
    float3 d = fibonacciSphere(i, _numMSSamples);

    /* Trace a ray to see what we hit. */
    SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
      _atmosphereRadius);

    float t_hit = intersection.endT;
    float3 hitPoint = O + t_hit * d;

    /* Add ground albedo times the transmittance to the second order
     * reflections if we hit the ground. */
    if (intersection.groundHit) {
      float mu = d.y;
      float2 groundUV = mapSky2DCoord(r, mu, _atmosphereRadius,
        _planetRadius, t_hit, true, _resT.y);
      float3 groundTransmittance = computeSkyTransmittance(groundUV);
      float3 groundAlbedo = 2 * _groundTint.xyz / PI;
      secondOrder += groundTransmittance * groundAlbedo
        * saturate(dot(L, normalize(hitPoint)));
    }

    /* Compute single scattering. */
    SSResult ss = computeSSForMS(O, d, t_hit, t_hit, intersection.groundHit, L);
    secondOrder += (t_hit * ss.shadows) / (4 * PI);
    transferFunction += t_hit * ss.noShadows;
  }

  /* Multiply by the isotropic phase function 1/4pi and divide by the number
   * of samples we took. */
  secondOrder /= 4.0 * PI * float(_numMSSamples);
  transferFunction /= 4.0 * PI * float(_numMSSamples);
  transferFunction = 1.0 / (1.0 - transferFunction);

  _MS_RW[id.xy] = secondOrder * transferFunction;
}

[numthreads(8,8,1)]
void MSAcc(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle and a
   * radial angle. */
  float u_mu = (id.x + 0.5) / float(_resSS.x);
  float u_theta = (id.y + 0.5) / float(_resSS.y);

  float3 O = GetCameraPositionPlanetSpace();
  float r = length(O);

  float2 mu_theta = unmapSkyRenderCoordinate(r, u_mu, u_theta,
    _atmosphereRadius, _planetRadius, _resSS.x, _resSS.y);

  float3 d = mu_theta_to_d(mu_theta.x, mu_theta.y, O);

  /* Check if we hit the ground. TODO: maybe just check against horizon
   * angle? Hm. TODO: need to case out above atmo. */
  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);

  _MSAcc_RW[id.xy] = computeMS(O, d, intersection.endT, intersection.endT, intersection.groundHit);
}
