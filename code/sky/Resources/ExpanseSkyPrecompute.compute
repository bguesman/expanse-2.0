#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// Each #kernel tells which function to compile; you can have many kernels
/* For now, we'll start with one kernel to compute the transmittance
 * tables. */
#pragma kernel T main=T
#pragma kernel LP main=LP
#pragma kernel SS main=SS
#pragma kernel GI main=GI
#pragma kernel MS main=MS
#pragma kernel MSAcc main=MSAcc

#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/CommonLighting.hlsl"
#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Sampling/Sampling.hlsl"
#include "../ExpanseSkyCommon.hlsl"
#include "../ExpanseSkyMapping.hlsl"

/* RW Textures. */
/* Transmittance. */
RW_TEXTURE2D(float3, _T_RW);

/* Light Pollution. */
RW_TEXTURE2D_ARRAY(float3, _LP_RW);

/* Single scattering, with and without shadows. */
RW_TEXTURE2D_ARRAY(float3, _SS_RW);
RW_TEXTURE2D_ARRAY(float3, _SSNoShadow_RW);

/* Multiple scattering. */
RW_TEXTURE2D(float3, _MS_RW);

/* Multiple scattering accumulation. */
RW_TEXTURE2D_ARRAY(float3, _MSAcc_RW);

/* Ground Irradiance. */
RW_TEXTURE2D_ARRAY(float3, _GI_RW);

/******************************************************************************/
/****************************** TEXTURE WRITERS *******************************/
/******************************************************************************/

void writeSS(uint2 id, float3 val, int i) {
  _SS_RW[uint3(id, (uint) i)] = val;
}

void writeSSNoShadow(uint2 id, float3 val, int i) {
  _SSNoShadow_RW[uint3(id, (uint) i)] = val;
}

void writeGI(uint2 id, float3 val, int i) {
  _GI_RW[float3(id, i)] = val;
}

void writeMSAcc(uint2 id, float3 val, int i) {
  _MSAcc_RW[uint3(id, (uint) i)] = val;
}

/******************************************************************************/
/**************************** END TEXTURE WRITERS *****************************/
/******************************************************************************/

// TODO: lots of indexing hacks in here to avoid the "texture is not set" shit.
// annoying as fuck and we will have to fix at some point.

[numthreads(4,4,1)]
void T(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle and a
   * height. */
  float u_r = (id.x + 0.5f) / float(_resT.x);
  float u_mu = (id.y + 0.5f) / float(_resT.y);

  float2 r_mu = unmapSky2DCoord(u_r, u_mu, _atmosphereRadius, _planetRadius);

  float r = r_mu.x;
  float mu = r_mu.y;

  float3 O = float3(0, r, 0);
  float3 d = float3(safeSqrt(1 - mu * mu), mu, 0);

  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);
  float3 endPoint = O + d * intersection.endT;

  /* Compute optical depth for all enabled atmosphere layers. */
  float3 power = float3(0, 0, 0);
  for (int i = 0; i < _numActiveLayers; i++) {
    float opticalDepth = computeOpticalDepth(_layerDensityDistribution[i],
      O, endPoint, _layerHeight[i], _layerThickness[i], _layerDensity[i],
      _layerAttenuationBias[i], _layerAttenuationDistance[i],
      _layerUseDensityAttenuation[i], _numTSamples);
    /* Absorption is about 1.1x scattering for aerosols. */
    power += opticalDepth * _layerCoefficientsA[i].xyz;
  }

  /* Compute transmittance from optical depth. */
  float3 T = saturate(exp(-power));

  _T_RW[id.xy] = T;
}

[numthreads(4,4,1)]
void LP(uint3 id : SV_DispatchThreadID) {
}

[numthreads(4,4,1)]
void SS(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle, a
   * height, and the sun zenith and azimuth angles. */
  float2 u_r_mu = deepTexIndexToUV(id.x, _resSS.x, _resSS.y);
  /* Height. */
  float u_r = u_r_mu.x;
  /* Viewing angle. */
  float u_mu = u_r_mu.y;

  float2 u_mu_l_u_nu = deepTexIndexToUV(id.y, _resSS.z, _resSS.w);
  /* Sun zenith angle. */
  float u_mu_l = u_mu_l_u_nu.x;
  /* Sun azimuth angle. */
  float u_nu = u_mu_l_u_nu.y;

  float4 ssCoord = unmapSky4DCoord(u_r, u_mu, u_mu_l, u_nu, _atmosphereRadius,
    _planetRadius);

  float r = ssCoord.x;
  float mu = ssCoord.y;
  float mu_l = ssCoord.z;
  float nu = ssCoord.w;

  float3 O = float3(0, r, 0);
  float3 d = float3(safeSqrt(1 - mu * mu), mu, 0);
  float3 L = float3(nu*safeSqrt(1 - mu_l*mu_l), mu_l,
    safeSqrt(1 - nu * nu)*safeSqrt(1 - mu_l*mu_l));

  /* Trace a ray to see what we hit. */
  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);

  float3 endPoint = O + d * intersection.endT;
  float t_hit = intersection.endT;

  float3 inScattering[MAX_LAYERS];
  float3 inScatteringNoShadows[MAX_LAYERS];
  float scaledDensity[MAX_LAYERS];
  for (int j = 0; j < _numActiveLayers; j++) {
    inScattering[j] = float3(0, 0, 0);
    inScatteringNoShadows[j] = float3(0, 0, 0);
    scaledDensity[j] = 0;
  }

  for (int i = 0; i < _numSSSamples; i++) {
    float sampleT = 0.0;
    float ds = 0.0;
    if (_useImportanceSampling) {
      float2 t_ds = t_hit * generateCubicSampleFromIndex(i, _numSSSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    } else {
      /* Distribute linearly. */
      float2 t_ds = t_hit * generateLinearSampleFromIndex(i, _numSSSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    }

    float3 samplePoint = O + d * sampleT;
    float3 normalizedSamplePoint = normalize(samplePoint);

    /* Compute the scaled density of the layer at the sample point. */
    for (int j = 0; j < _numActiveLayers; j++) {
      scaledDensity[j] = ds * computeDensity(_layerDensityDistribution[j],
        samplePoint, _layerHeight[j], _layerThickness[j], _layerDensity[j],
        _layerUseDensityAttenuation[j], sampleT, _layerAttenuationBias[j],
        _layerAttenuationDistance[j]);
    }

    /* Compute transmittance from O to sample point, and then from sample
     * point through to the light hit. */
    float2 oToSample = mapSky2DCoord(length(O),
      mu, _atmosphereRadius, _planetRadius, t_hit, intersection.groundHit);

    float3 T_oToSample = SAMPLE_TEXTURE2D_LOD(_T,
      s_linear_clamp_sampler, oToSample, 0).rgb;

    /* Our transmittance value for O to the sample point is too large---we
     * need to divide out the transmittance from the sample point to the
     * atmosphere, or ground, depending on what we hit. */
    float2 sampleOut = mapSky2DCoord(length(samplePoint),
      clampCosine(dot(normalizedSamplePoint, d)), _atmosphereRadius,
      _planetRadius, t_hit - sampleT, intersection.groundHit);
    float3 T_sampleOut = SAMPLE_TEXTURE2D_LOD(_T,
      s_linear_clamp_sampler, sampleOut, 0).rgb;
    /* Clamp sample out for division. */
    T_sampleOut = max(T_sampleOut, FLT_EPSILON);
    T_oToSample /= T_sampleOut;

    for (int j = 0; j < _numActiveLayers; j++) {
      inScatteringNoShadows[j] += scaledDensity[j] * T_oToSample;
    }

    /* Trace a ray from the sample point to the light to check visibility.
     * Displace just a little bit just in case we hit the ground. */
    SkyIntersectionData lightIntersection = traceSkyVolume(samplePoint * 1.001,
      L, _planetRadius, _atmosphereRadius);

    float3 lightEndPoint = samplePoint + L * lightIntersection.endT;
    float t_light_hit = lightIntersection.endT;

    /* Compute the light transmittance to the sample point. */
    float2 sampleToL = mapSky2DCoord(length(samplePoint),
      clampCosine(dot(normalizedSamplePoint, L)), _atmosphereRadius,
      _planetRadius, t_light_hit, lightIntersection.groundHit);
    /* Compute transmittance through sample to light hit point. */
    float3 T_sampleToL = SAMPLE_TEXTURE2D_LOD(_T,
      s_linear_clamp_sampler, sampleToL, 0).rgb;

    float3 T = T_oToSample * T_sampleToL;

    if (lightIntersection.groundHit) {
      if (!intersection.groundHit) {
        /* We'll add the light scattered off the ground surface. */
        float dot_L_sample = saturate(dot(normalize(L), normalize(lightEndPoint)));
        float3 groundAlbedo = _groundTint.xyz / PI;
        for (int j = 0; j < _numActiveLayers; j++) {
          inScattering[j] += scaledDensity[j] * T * (dot_L_sample * groundAlbedo);
        }
      }
    } else {
      for (int j = 0; j < _numActiveLayers; j++) {
        inScattering[j] += scaledDensity[j] * T;
      }
    }
  }

  for (int k = 0; k < _numActiveLayers; k++) {
    writeSS(id.xy, inScattering[k], k);
    writeSSNoShadow(id.xy, inScatteringNoShadows[k], k);
  }
}

[numthreads(4,1,1)]
void GI(uint3 id : SV_DispatchThreadID) {
  float u_mu_l = (id.x + 0.5f) / float(_resGI);

  float2 r_mu_l = unmapSky1DCoord(u_mu_l, _planetRadius);
  float r = r_mu_l.x;
  float mu_l = r_mu_l.y;

  float3 O = float3(0, r + 10, 0);
  float3 O_normalized = float3(0, 1, 0);
  float3 L = float3(safeSqrt(1 - mu_l * mu_l), mu_l, 0);

  float3 gi[MAX_LAYERS];
  for (int j = 0; j < _numActiveLayers; j++) {
    gi[j] = float3(0, 0, 0);
  }

  for (int i = 0; i < _numGISamples; i++) {
    /* Generate fibonacci hemisphere dir based on i. */
    float3 d = fibonacciHemisphere(i, _numGISamples);

    float mu = dot(d, O_normalized);

    float3 proj_L = normalize(L - O_normalized * mu_l);
    float3 proj_d = normalize(d - O_normalized * dot(O_normalized, d));
    /* Take their dot product to get the cosine of the angle between them. */
    float nu = clampCosine(dot(proj_L, proj_d));

    /* Sample the sky table for each layer. */
    SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
      _atmosphereRadius);
    if (!intersection.groundHit) {
      float t_hit = intersection.endT;
      TexCoord4D ssCoord = mapSky4DCoord(r, mu, mu_l, nu,
        _atmosphereRadius, _planetRadius, t_hit, false, _resSS.x, _resSS.y,
        _resSS.z, _resSS.w);

      for (int j = 0; j < _numActiveLayers; j++) {
        float3 ss = sampleSSTexture(ssCoord, j);
        /* Compute single scattering contribution using phase functions. */
        float dot_L_d = dot(L, d);
        float phase = computePhase(dot_L_d, _layerAnisotropy[j], _layerPhaseFunction[j]);
        gi[j] += ss * phase;
      }
    }
  }

  for (int j = 0; j < _numActiveLayers; j++) {
    writeGI(id.xy, gi[j] * 2 * PI / float(_numGISamples), j);
  }

}

[numthreads(4,4,1)]
void MS(uint3 id : SV_DispatchThreadID) {
  /* Unmap the uv coordinates to get the light direction and sample point. */
  float u_r = (id.x + 0.5f) / float(_resMS.x);
  float u_mu_l = (id.y + 0.5f) / float(_resMS.y);

  float2 r_mu_l = unmapMSCoordinate(u_r, u_mu_l, _atmosphereRadius, _planetRadius);

  float r = r_mu_l.x;
  float mu_l = r_mu_l.y;

  float3 O = float3(0, r + 0.01, 0);
  float3 O_normalized = float3(0, 1, 0);
  float3 L = float3(safeSqrt(1 - mu_l * mu_l), mu_l, 0);

  /* Sample a bunch of directions, uniformly distributed on a sphere. */
  float3 secondOrder = float3(0, 0, 0);
  float3 transferFunction = float3(0, 0, 0);
  for (int i = 0; i < _numMSSamples; i++) {
    /* Get the sample direction. */
    float3 d = fibonacciSphere(i, _numMSSamples);

    /* Trace a ray to see what we hit. */
    SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
      _atmosphereRadius);

    float t_hit = intersection.endT;
    float3 hitPoint = O + t_hit * d;

    /* We have r and mu_l, but we need to compute mu and nu. */
    /* Mu is just the dot(O, d), aka just the y component of d. */
    float mu = d.y;

    /* Nu we can compute as we've done before: by projecting d and
     * L onto the plane defined by O and taking the dot product. */
    float3 proj_L = normalize(L - O_normalized * mu_l);
    float3 proj_d = normalize(d - O_normalized * dot(O_normalized, d));
    /* Take their dot product to get the cosine of the angle between them. */
    float nu = clampCosine(dot(proj_L, proj_d));

    /* Add ground albedo times the transmittance to the second order
     * reflections if we hit the ground. */
    if (intersection.groundHit) {
      float2 groundUV = mapSky2DCoord(r, mu, _atmosphereRadius,
        _planetRadius, t_hit, intersection.groundHit);
      float3 groundTransmittance = SAMPLE_TEXTURE2D_LOD(_T,
        s_linear_clamp_sampler, groundUV, 0).rgb;
      float3 groundAlbedo = 2 * _groundTint.xyz / PI;
      secondOrder += groundTransmittance * groundAlbedo
        * saturate(dot(L, normalize(hitPoint)));
    }

    /* Sample the single scattering tables. */
    TexCoord4D ssCoord = mapSky4DCoord(r, mu, mu_l, nu,
      _atmosphereRadius, _planetRadius, t_hit, intersection.groundHit,
      _resSS.x, _resSS.y, _resSS.z, _resSS.w);
    for (int j = 0; j < _numActiveLayers; j++) {
      float3 ss = sampleSSTexture(ssCoord, j);
      secondOrder += (_layerCoefficientsS[j].xyz * 2 * _layerTint[j].xyz * ss)
        / (4.0 * PI);
      float3 ssNoShadow = sampleSSNoShadowTexture(ssCoord, j);
      transferFunction += (_layerCoefficientsS[j].xyz * 2 * _layerTint[j].xyz * ssNoShadow);
    }
  }

  /* Multiply by the isotropic phase function 1/4pi and divide by the number
   * of samples we took. */
  secondOrder /= 4.0 * PI * float(_numMSSamples);
  transferFunction /= 4.0 * PI * float(_numMSSamples);
  transferFunction = 1.0 / (1.0 - transferFunction);

  _MS_RW[id.xy] = secondOrder * transferFunction;
}

[numthreads(4,4,1)]
void MSAcc(uint3 id : SV_DispatchThreadID) {
  /* Get the uv for this id and unwrap it to a viewing angle, a
   * height, and the sun zenith and azimuth angles. */
  float2 u_r_mu = deepTexIndexToUV(id.x, _resMSAcc.x, _resMSAcc.y);
  /* Height. */
  float u_r = u_r_mu.x;
  /* Viewing angle. */
  float u_mu = u_r_mu.y;

  float2 u_mu_l_u_nu = deepTexIndexToUV(id.y, _resMSAcc.z, _resMSAcc.w);
  /* Sun zenith angle. */
  float u_mu_l = u_mu_l_u_nu.x;
  /* Sun azimuth angle. */
  float u_nu = u_mu_l_u_nu.y;

  float4 ssCoord = unmapSky4DCoord(u_r, u_mu, u_mu_l,
    u_nu, _atmosphereRadius, _planetRadius);

  float r = ssCoord.x;
  float mu = ssCoord.y;
  float mu_l = ssCoord.z;
  float nu = ssCoord.w;

  float3 O = float3(0, r, 0);
  float3 d = float3(safeSqrt(1 - mu * mu), mu, 0);
  float3 L = float3(nu*safeSqrt(1 - mu_l*mu_l), mu_l,
    safeSqrt(1 - nu * nu)*safeSqrt(1 - mu_l*mu_l));

  SkyIntersectionData intersection = traceSkyVolume(O, d, _planetRadius,
    _atmosphereRadius);
  float3 endPoint = O + d * intersection.endT;
  float t_hit = intersection.endT;

  float3 multipleScattering[MAX_LAYERS];
  for (int j = 0; j < MAX_LAYERS; j++) {
    multipleScattering[j] = float3(0, 0, 0);
  }

  for (int i = 0; i < _numMSAccumulationSamples; i++) {
    float sampleT = 0.0;
    float ds = 0.0;
    if (_useImportanceSampling) {
      float2 t_ds = t_hit * generateCubicSampleFromIndex(i, _numMSAccumulationSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    } else {
      /* Distribute linearly. */
      float2 t_ds = t_hit * generateLinearSampleFromIndex(i, _numMSAccumulationSamples);
      sampleT = t_ds.x;
      ds = t_ds.y;
    }

    float3 samplePoint = O + d * sampleT;

    float r_sample = length(samplePoint);
    float mu_l_sample = dot(normalize(samplePoint), L);
    float2 msUV = mapMSCoordinate(r_sample, mu_l_sample,
      _atmosphereRadius, _planetRadius);
    float3 msContrib = SAMPLE_TEXTURE2D_LOD(_MS, s_linear_clamp_sampler, msUV, 0).xyz;

    /* Compute the scaled density of the layer at the sample point. */
    for (int j = 0; j < _numActiveLayers; j++) {
      float scaledDensity = ds * computeDensity(_layerDensityDistribution[j],
        samplePoint, _layerHeight[j], _layerThickness[j], _layerDensity[j],
        _layerUseDensityAttenuation[j], sampleT, _layerAttenuationBias[j],
        _layerAttenuationDistance[j]);
      multipleScattering[j] += msContrib * scaledDensity;
    }
  }

  for (int k = 0; k < _numActiveLayers; k++) {
    writeMSAcc(id.xy, multipleScattering[k], k);
  }

}
